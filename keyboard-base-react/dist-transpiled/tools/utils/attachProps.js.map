{"version":3,"file":"attachProps.js","sourceRoot":"","sources":["../../../src/tools/utils/attachProps.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,MAAM,QAAQ,CAAA;AAExC,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,IAAiB,EAAE,QAAa,EAAE,WAAgB,EAAE,EAAE,EAAE;IAClF,iDAAiD;IACjD,MAAM,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAA;IAClE,IAAI,SAAS,KAAK,EAAE,EAAE;QACpB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAA;KAC3B;IAED,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACnC,IACE,IAAI,KAAK,UAAU;YACnB,IAAI,KAAK,OAAO;YAChB,IAAI,KAAK,KAAK;YACd,IAAI,KAAK,OAAO;YAChB,IAAI,KAAK,WAAW;YACpB,IAAI,KAAK,cAAc,EACvB;YACA,OAAM;SACP;QACD,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE;YACjE,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;YACnC,MAAM,WAAW,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;YAEvE,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAE;gBAClC,SAAS,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAA;aAC7C;SACF;aAAM;YACJ,IAAY,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAA;YACpC,MAAM,QAAQ,GAAG,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAA;YACtC,IAAI,QAAQ,KAAK,QAAQ,EAAE;gBACzB,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAA;aACzD;iBAAM;gBACJ,IAAY,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAA;aACrC;SACF;IACH,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,SAAuB,EAAE,QAAa,EAAE,QAAa,EAAE,EAAE;IACpF,MAAM,YAAY,GAAW,QAAQ,CAAC,SAAS,IAAI,QAAQ,CAAC,KAAK,CAAA;IACjE,MAAM,YAAY,GAAW,QAAQ,CAAC,SAAS,IAAI,QAAQ,CAAC,KAAK,CAAA;IACjE,0CAA0C;IAC1C,MAAM,cAAc,GAAG,UAAU,CAAC,SAAS,CAAC,CAAA;IAC5C,MAAM,mBAAmB,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAA;IACnF,MAAM,cAAc,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAA;IAC9E,MAAM,eAAe,GAAa,EAAE,CAAA;IACpC,4DAA4D;IAC5D,wDAAwD;IACxD,cAAc,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;QACpC,IAAI,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YACzC,uEAAuE;YACvE,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;YAClC,mBAAmB,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;SACzC;aAAM,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YAC5C,4CAA4C;YAC5C,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;SACnC;IACH,CAAC,CAAC,CAAA;IACF,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;IACzD,OAAO,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AAClC,CAAC,CAAA;AAED;;;GAGG;AACH,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAAC,eAAuB,EAAE,MAAgB,QAAQ,EAAE,EAAE;IACpF,MAAM,SAAS,GAAG,KAAO,eAAe,EAAE,CAAA;IAC1C,IAAI,WAAW,GAAG,SAAS,IAAI,GAAG,CAAA;IAElC,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,OAAO,GAAG,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;QACxC,OAAO,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,CAAC,CAAA;QAC1C,WAAW,GAAG,OAAQ,OAAe,CAAC,SAAS,CAAC,KAAK,UAAU,CAAA;KAChE;IAED,OAAO,WAAW,CAAA;AACpB,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,SAAS,GAAG,CACvB,IAAiF,EACjF,SAAiB,EACjB,eAAmC,EACnC,EAAE;IACF,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,CAAA;IACxD,MAAM,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,CAAA;IAE7C,+CAA+C;IAC/C,IAAI,eAAe,EAAE;QACnB,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,eAAe,CAAC,CAAA;KACrD;IAED,qBAAqB;IACrB,IAAI,CAAC,gBAAgB,CACnB,SAAS,EACT,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,SAAS,OAAO,CAAC,CAAQ;QAChD,IAAI,eAAe,EAAE;YACnB,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAA;SAC9B;IACH,CAAC,CAAC,CACH,CAAA;AACH,CAAC,CAAA;AAED,MAAM,UAAU,GAAG,CAAC,GAA4B,EAAE,EAAE;IAClD,MAAM,GAAG,GAAG,IAAI,GAAG,EAAkB,CACpC;IAAC,GAAgB,CAAC,OAAO,CAAC,CAAC,CAAS,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;IACxD,OAAO,GAAG,CAAA;AACZ,CAAC,CAAA","sourcesContent":["import { camelToDashCase } from './case'\n\nexport const attachProps = (node: HTMLElement, newProps: any, oldProps: any = {}) => {\n  // add any classes in className to the class list\n  const className = getClassName(node.classList, newProps, oldProps)\n  if (className !== '') {\n    node.className = className\n  }\n\n  Object.keys(newProps).forEach(name => {\n    if (\n      name === 'children' ||\n      name === 'style' ||\n      name === 'ref' ||\n      name === 'class' ||\n      name === 'className' ||\n      name === 'forwardedRef'\n    ) {\n      return\n    }\n    if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n      const eventName = name.substring(2)\n      const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1)\n\n      if (!isCoveredByReact(eventNameLc)) {\n        syncEvent(node, eventNameLc, newProps[name])\n      }\n    } else {\n      (node as any)[name] = newProps[name]\n      const propType = typeof newProps[name]\n      if (propType === 'string') {\n        node.setAttribute(camelToDashCase(name), newProps[name])\n      } else {\n        (node as any)[name] = newProps[name]\n      }\n    }\n  })\n}\n\nexport const getClassName = (classList: DOMTokenList, newProps: any, oldProps: any) => {\n  const newClassProp: string = newProps.className || newProps.class\n  const oldClassProp: string = oldProps.className || oldProps.class\n  // map the classes to Maps for performance\n  const currentClasses = arrayToMap(classList)\n  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : [])\n  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : [])\n  const finalClassNames: string[] = []\n  // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n  currentClasses.forEach(currentClass => {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass)\n      incomingPropClasses.delete(currentClass)\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass)\n    }\n  })\n  incomingPropClasses.forEach(s => finalClassNames.push(s))\n  return finalClassNames.join(' ')\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nexport const isCoveredByReact = (eventNameSuffix: string, doc: Document = document) => {\n  const eventName = `on${  eventNameSuffix}`\n  let isSupported = eventName in doc\n\n  if (!isSupported) {\n    const element = doc.createElement('div')\n    element.setAttribute(eventName, 'return;')\n    isSupported = typeof (element as any)[eventName] === 'function'\n  }\n\n  return isSupported\n}\n\nexport const syncEvent = (\n  node: Element & { __events?: { [key: string]: ((e: Event) => any) | undefined } },\n  eventName: string,\n  newEventHandler?: (e: Event) => any,\n) => {\n  const eventStore = node.__events || (node.__events = {})\n  const oldEventHandler = eventStore[eventName]\n\n  // Remove old listener so they don't double up.\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler)\n  }\n\n  // Bind new listener.\n  node.addEventListener(\n    eventName,\n    (eventStore[eventName] = function handler(e: Event) {\n      if (newEventHandler) {\n        newEventHandler.call(this, e)\n      }\n    }),\n  )\n}\n\nconst arrayToMap = (arr: string[] | DOMTokenList) => {\n  const map = new Map<string, string>()\n  ;(arr as string[]).forEach((s: string) => map.set(s, s))\n  return map\n}\n"]}